<style>
    .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
    }
    .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: var(--primary);
        border-radius: 20px;
        opacity: 0.5;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background-color: var(--primary);
        opacity: 0.8;
    }
    /* Firefox */
    .custom-scrollbar {
        scrollbar-width: thin;
        scrollbar-color: var(--primary) transparent;
    }

    /* Liquid glass effect */
    #notification-minimized {
        backdrop-filter: blur(12px) saturate(180%);
        -webkit-backdrop-filter: blur(12px) saturate(180%);
    }

    #notification-panel {
        backdrop-filter: blur(16px) saturate(180%);
        -webkit-backdrop-filter: blur(16px) saturate(180%);
    }
</style>

<div id="new-post-notification" class="fixed bottom-20 right-4 z-50 flex flex-col items-end pointer-events-none">
    <!-- Minimized State (Bell Icon) -->
    <button id="notification-minimized" class="pointer-events-auto bg-blue-100/80 dark:bg-blue-900/40 border border-blue-300 dark:border-blue-700 text-blue-600 dark:text-blue-300 p-3 rounded-full shadow-lg transform translate-y-0 opacity-0 transition-all duration-500 ease-[cubic-bezier(0.34,1.56,0.64,1)] hover:scale-110 active:scale-95 flex items-center justify-center relative group ml-2 z-10">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9"></path><path d="M10.3 21a1.94 1.94 0 0 0 3.4 0"></path></svg>
        <span id="notification-dot" class="absolute top-0 right-0 w-3 h-3 bg-red-500 rounded-full border-2 border-blue-100 dark:border-blue-900 hidden animate-pulse"></span>
    </button>

    <!-- Expanded State (Panel) -->
    <div id="notification-panel" class="pointer-events-auto bg-blue-100/80 dark:bg-blue-900/40 border border-blue-300 dark:border-blue-700 rounded-xl shadow-lg p-4 max-w-[90vw] w-80 transform -translate-y-4 opacity-0 scale-95 origin-bottom-right transition-all duration-300 hidden absolute bottom-full right-0 mb-2">
        <div class="flex items-center justify-between mb-3">
            <div class="flex items-center gap-2 text-blue-600 dark:text-blue-300">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg>
                <h3 class="font-bold text-black dark:text-white">发现新文章</h3>
            </div>
            <div class="flex items-center gap-1">
                <button id="clear-notification" class="text-black/50 dark:text-white/50 hover:text-red-500 transition-colors p-1 rounded-md hover:bg-red-500/10" title="清空通知">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path></svg>
                </button>
                <button id="minimize-notification" class="text-black/50 dark:text-white/50 hover:text-[var(--primary)] transition-colors p-1 rounded-md hover:bg-[var(--primary)]/10" title="隐藏">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
        </div>
        <div id="new-post-list" class="text-sm text-black/80 dark:text-white/80 transition-colors space-y-1 max-h-[60vh] overflow-y-auto overflow-x-hidden custom-scrollbar"></div>
    </div>
</div>

<script>
    import * as Diff from 'diff';

    // Type definitions
    interface Post {
        title: string;
        link: string;
        guid: string;
        pubDate: number;
        description: string;
        content: string;
        isUpdated?: boolean;
        diff?: Diff.Change[];
    }

    interface StoredPost extends Post {
        id: string;
    }

    (async function() {
    const DB_NAME = 'mapleblog-rss-store';
    const DB_VERSION = 2;
    const STORE_NAME = 'posts';
    const LOCAL_STORAGE_KEY = 'blog-posts-cache';
    const NOTIFICATION_ID = 'new-post-notification';
    const LIST_ID = 'new-post-list';

    // Compute a context-aware ID for the current site/path
    const SCOPE_ID = window.location.pathname.split('/')[1] || 'root';

    // IndexedDB Helpers
    function openDB(): Promise<IDBDatabase> {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
                const db = (event.target as IDBOpenDBRequest).result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    // We use 'id' as the keyPath which will be a composite key
                    db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                }
            };
        });
    }

    function generateId(guid: string): string {
        // Create a unique ID combining the scope (pathname root) and the article guid
        return `${SCOPE_ID}:${guid}`;
    }

    function getStoredPosts(db: IDBDatabase): Promise<StoredPost[]> {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result as StoredPost[]);
            request.onerror = () => reject(request.error);
        });
    }

    function savePosts(db: IDBDatabase, posts: Post[]): Promise<void> {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);

            posts.forEach(post => {
                // Ensure we save with the scoped ID
                const itemToSave: StoredPost = { ...post, id: generateId(post.guid) };
                store.put(itemToSave);
            });

            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        });
    }

    // Helper to get current RSS items
    async function fetchRSS(): Promise<Post[]> {
        try {
            const response = await fetch('/rss.xml', { cache: 'no-store' });
            const text = await response.text();
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, 'text/xml');
            const items = Array.from(xml.querySelectorAll('item'));

            return items.map(item => {
                const title = item.querySelector('title')?.textContent || '';
                const link = item.querySelector('link')?.textContent || '';
                const guid = item.querySelector('guid')?.textContent || link;
                const pubDate = new Date(item.querySelector('pubDate')?.textContent || '').getTime();
                const description = item.querySelector('description')?.textContent || '';

                // Try to get content from multiple possible sources to ensure we capture it
                const contentEncoded = item.getElementsByTagNameNS('http://purl.org/rss/1.0/modules/content/', 'encoded')[0]?.textContent;
                const content = contentEncoded ||
                                item.getElementsByTagName('content:encoded')[0]?.textContent ||
                                item.querySelector('content')?.textContent || '';

                return {
                    title,
                    link,
                    guid,
                    pubDate,
                    description,
                    content // Full content is stored here
                };
            });
        } catch (e) {
            console.error('Failed to fetch RSS:', e);
            return [];
        }
    }

    // Helper to compute text diff
    function computeDiff(oldText: string, newText: string): Diff.Change[] | null {
        if (!oldText || !newText) return null;

        // Strip HTML tags for cleaner comparison (optional, but usually better for text posts)
        const stripHtml = (html: string): string => {
            const tmp = document.createElement("DIV");
            tmp.innerHTML = html;
            return tmp.textContent || tmp.innerText || "";
        };

        const cleanOld = stripHtml(oldText);
        const cleanNew = stripHtml(newText);

        // Use 'diff' library to compute line-by-line diff
        const diffs = Diff.diffLines(cleanOld, cleanNew);

        // Filter to only show relevant changes (context)
        // We don't want to show the whole file if only one line changed.
        // Simple logic: return chunks that are added or removed, plus a bit of context.

        // But for simplicity in UI rendering, let's just return the diff structure
        // and let the UI render it with colors.
        // We only return if there are actual changes.
        const hasChanges = diffs.some(part => part.added || part.removed);

        if (!hasChanges) return null;

        return diffs;
    }

    // Helper to show notification
    function showNotification(newPosts: Post[], timestamp: number, isFresh: boolean, initTime: number): void {
        const minimizedBtn = document.getElementById('notification-minimized') as HTMLButtonElement | null;
        const panel = document.getElementById('notification-panel') as HTMLDivElement | null;
        const list = document.getElementById(LIST_ID) as HTMLDivElement | null;
        const dot = document.getElementById('notification-dot') as HTMLSpanElement | null;
        const minimizeBtn = document.getElementById('minimize-notification') as HTMLButtonElement | null;
        const clearBtn = document.getElementById('clear-notification') as HTMLButtonElement | null;
        const NOTIFICATION_STATE_KEY = 'mapleblog-notification-state';
        const INIT_TIME_KEY = 'mapleblog-notification-init-time';

        if (!minimizedBtn || !panel || !list) return;

        // Show the minimized bell with animation
        // Add a small delay to make the entrance noticeable after page load
        requestAnimationFrame(() => {
            if (minimizedBtn) {
                // Reset position and visibility
                minimizedBtn.style.position = '';
                minimizedBtn.style.left = '';
                minimizedBtn.style.top = '';
                // Remove hidden classes
                minimizedBtn.classList.remove('translate-y-20', 'opacity-0');
                minimizedBtn.classList.remove('pointer-events-none'); // Allow clicks when visible
            }
        });

        const initTimeStr = new Date(initTime).toLocaleString();
        const checkTimeStr = new Date(timestamp).toLocaleString();

        // Logic for "No updates"
        if (newPosts.length === 0) {
             if (list) {
                 list.innerHTML = `<div class="text-center text-gray-500 dark:text-gray-400 py-4">
                    <p class="text-sm font-medium mb-2">暂无文章更新</p>
                    <div class="text-xs opacity-70 bg-gray-100 dark:bg-gray-800 rounded px-2 py-1 inline-block">
                        ${initTimeStr} - ${checkTimeStr}
                    </div>
                 </div>`;
             }
             dot?.classList.add('hidden');

             // Setup event listeners even if no posts (so it can be opened)
             setupEventListeners();
             return;
        }

        // Show timestamp header
        let html = `
            <div class="text-xs text-gray-500 dark:text-gray-400 mb-2 px-1 flex flex-col gap-0.5">
                <div class="font-medium">发现更新</div>
                <div class="opacity-70 text-[10px]">${initTimeStr} - ${checkTimeStr}</div>
            </div>`;

        newPosts.forEach(post => {
            const isUpdated = post.isUpdated || false;
            const badge = isUpdated
                ? '<span class="text-xs bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-300 px-1.5 py-0.5 rounded ml-2">更新</span>'
                : '<span class="text-xs bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 px-1.5 py-0.5 rounded ml-2">新文章</span>';

            // Generate Diff View button if updated
            let diffButton = '';
            const safeId = 'diff-' + post.guid.replace(/[^a-zA-Z0-9-_]/g, '_');

            if (isUpdated && post.diff) {
                diffButton = `
                <button data-diff-toggle="${safeId}" class="ml-auto text-xs text-[var(--primary)] hover:underline focus:outline-none pointer-events-auto">
                    查看变更
                </button>`;
            }

            html += `
            <div class="mb-2 last:mb-0">
                <div class="flex items-center justify-between p-2 rounded-lg hover:bg-[var(--primary)]/5 transition-colors">
                    <a href="${post.link}" class="font-medium truncate pr-2 hover:text-[var(--primary)] transition-colors text-black dark:text-white block flex-1">
                        ${post.title}
                    </a>
                    <div class="flex items-center shrink-0">
                        ${diffButton}
                        ${badge}
                    </div>
                </div>
                ${isUpdated && post.diff ? `
                <div id="${safeId}" class="hidden mt-2 p-2 bg-gray-50 dark:bg-gray-800 rounded text-xs overflow-x-auto border border-gray-200 dark:border-gray-700 max-h-60 overflow-y-auto">
                    ${post.diff.map(part => {
                        const colorClass = part.added ? 'bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300 block my-1 p-1 rounded break-all whitespace-pre-wrap' :
                                         part.removed ? 'bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300 block my-1 p-1 rounded break-all whitespace-pre-wrap' :
                                         'text-gray-500 dark:text-gray-400 block my-1 p-1 break-all whitespace-pre-wrap';
                        return `<div class="${colorClass}">${part.value}</div>`;
                    }).join('')}
                </div>
                ` : ''}
            </div>`;
        });

        if (list) {
            list.innerHTML = html;
        }

        // Show red dot ONLY if it is a fresh update
        if (isFresh) {
             dot?.classList.remove('hidden');
             // Auto-open panel on first load if there are updates
             setTimeout(() => {
                 openPanel();
             }, 1500);
        } else {
             dot?.classList.add('hidden');
        }

        setupEventListeners();

        function setupEventListeners() {
            // State management functions
            const openPanel = () => {
                if (panel) {
                    panel.classList.remove('hidden');
                    // Small delay to allow display:block to apply before transition
                    requestAnimationFrame(() => {
                        panel.classList.remove('-translate-y-4', 'opacity-0', 'scale-95');
                    });
                    dot?.classList.add('hidden'); // Hide dot when opened
                }
            };

            const closePanel = () => {
                if (panel) {
                    panel.classList.add('-translate-y-4', 'opacity-0', 'scale-95');
                    setTimeout(() => {
                        panel.classList.add('hidden');
                    }, 300); // Match transition duration
                }
            };

            // Event Listeners
            // Remove old listeners to prevent duplicates if called multiple times?
            // Actually, in this script structure, showNotification is called once per page load.
            if (minimizedBtn) {
                minimizedBtn.onclick = () => {
                    if (panel) {
                        if (panel.classList.contains('hidden')) {
                            openPanel();
                        } else {
                            closePanel();
                        }
                    }
                };

                if (minimizeBtn) {
                    minimizeBtn.onclick = (e: MouseEvent) => {
                        e.stopPropagation();
                        closePanel();
                        // Completely hide the bell after closing the panel via the 'X' button
                        // Wait for panel closing animation to finish
                        setTimeout(() => {
                            if (minimizedBtn) {
                                // Add animation classes
                                minimizedBtn.classList.add('translate-y-20', 'opacity-0');
                                // Add pointer-events-none after animation starts
                                setTimeout(() => {
                                    minimizedBtn.classList.add('pointer-events-none'); // Prevent clicks while hidden
                                    // Also move it off-screen to ensure it doesn't receive clicks
                                    minimizedBtn.style.position = 'fixed';
                                    minimizedBtn.style.left = '-100px';
                                    minimizedBtn.style.top = '-100px';
                                }, 100);
                            }
                        }, 300);
                    };
                }
            }

            if (clearBtn) {
                clearBtn.onclick = (e: MouseEvent) => {
                    e.stopPropagation();
                    // Clear state from localStorage
                    localStorage.removeItem(NOTIFICATION_STATE_KEY);

                    // Update init time to current time since we are "resetting" the baseline
                    const now = Date.now();
                    localStorage.setItem(INIT_TIME_KEY, now.toString());

                    // Refresh view with new init time
                    showNotification([], now, false, now);
                };
            }

            // Add event delegation for toggles
            // Ensure we don't add duplicate listeners to list
            // A simple way is to re-create the listener or check via a flag.
            // But since this function runs once, it's fine.
            if (list && !list.hasAttribute('data-listening')) {
                list.addEventListener('click', (e: MouseEvent) => {
                    const target = e.target as Element;
                    const btn = target.closest('[data-diff-toggle]') as HTMLElement | null;
                    if (btn) {
                        const targetId = btn.getAttribute('data-diff-toggle');
                        if (targetId) {
                            const element = document.getElementById(targetId);
                            if (element) {
                                element.classList.toggle('hidden');
                            }
                        }
                    }
                });
                list.setAttribute('data-listening', 'true');
            }
        }

        // Helper to trigger open from outside (used by auto-open logic above)
        // We need to expose openPanel or move the auto-open logic inside setupEventListeners or keep it here
        // The previous code called openPanel() which was defined below.
        // We need to make sure openPanel is available.
        function openPanel() {
            if (panel) {
                panel.classList.remove('hidden');
                // Small delay to allow display:block to apply before transition
                requestAnimationFrame(() => {
                    panel.classList.remove('-translate-y-4', 'opacity-0', 'scale-95');
                });
                dot?.classList.add('hidden');
            }
        }

        const closePanel = () => {
            if (panel) {
                panel.classList.add('-translate-y-4', 'opacity-0', 'scale-95');
                setTimeout(() => {
                    panel.classList.add('hidden');
                }, 300); // Match transition duration
            }
        };

        // Event Listeners
        if (minimizedBtn) {
            minimizedBtn.onclick = () => {
                if (panel) {
                    if (panel.classList.contains('hidden')) {
                        openPanel();
                    } else {
                        closePanel();
                    }
                }
            };

            if (minimizeBtn) {
                minimizeBtn.onclick = (e: MouseEvent) => {
                    e.stopPropagation();
                    closePanel();
                    setTimeout(() => {
                        // Add animation classes
                        minimizedBtn.classList.add('translate-y-20', 'opacity-0');
                        // Add pointer-events-none after animation starts
                        setTimeout(() => {
                            minimizedBtn.classList.add('pointer-events-none'); // Prevent clicks while hidden
                            // Also move it off-screen to ensure it doesn't receive clicks
                            minimizedBtn.style.position = 'fixed';
                            minimizedBtn.style.left = '-100px';
                            minimizedBtn.style.top = '-100px';
                        }, 100);
                    }, 300);
                };
            }

            if (clearBtn) {
                clearBtn.onclick = (e: MouseEvent) => {
                    e.stopPropagation();
                    localStorage.removeItem(NOTIFICATION_STATE_KEY);
                    const now = Date.now();
                    localStorage.setItem(INIT_TIME_KEY, now.toString());
                    showNotification([], now, false, now);
                };
            }
        }
    }

    // Main function
    async function main(): Promise<void> {
        try {
            const db = await openDB();
            const storedPosts = await getStoredPosts(db);
            const fetchedPosts = await fetchRSS();

            const initTime = Date.now();
            const NOTIFICATION_STATE_KEY = 'mapleblog-notification-state';
            const INIT_TIME_KEY = 'mapleblog-notification-init-time';

            const lastInitTime = localStorage.getItem(INIT_TIME_KEY);
            localStorage.setItem(INIT_TIME_KEY, initTime.toString());

            const isFresh = !lastInitTime;

            // Compare stored vs fetched
            const storedGuids = new Set(storedPosts.map(p => p.guid));
            const newPosts: Post[] = [];

            for (const post of fetchedPosts) {
                const existingPost = storedPosts.find(p => p.guid === post.guid);

                if (!existingPost) {
                    // New post
                    newPosts.push({ ...post, isUpdated: false });
                } else if (existingPost.content !== post.content) {
                    // Updated post
                    const diff = computeDiff(existingPost.content, post.content);
                    if (diff) {
                        newPosts.push({ ...post, isUpdated: true, diff });
                    }
                }
            }

            // Save all fetched posts (updates existing ones)
            await savePosts(db, fetchedPosts);

            // Always show notification, even if no new posts
            // This ensures the notification icon is always visible
            showNotification(newPosts, initTime, isFresh, initTime);
        } catch (error) {
            console.error('Error in new post notification:', error);
        }
    }

    // Expose toggleDiff function globally for HTML buttons
    (window as any).toggleDiff = function(id: string): void {
        const element = document.getElementById(id);
        if (element) {
            element.classList.toggle('hidden');
        }
    };

    // Run main function
    main();
    })();
</script>
